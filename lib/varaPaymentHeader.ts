import { PaymentRequiredResponse, PaymentPayload } from '@/lib/x402-protocol-types';
import { signWithKeypair } from 'x402-vara/client';
import { useApi, createUnsignedTransaction } from 'x402-vara/utils';
import { Keyring } from "@polkadot/keyring";
import { hexToU8a } from '@polkadot/util'

// Demo private key (generated by scripts/generate-account.ts)
const DEMO_PRIVATE_KEY = process.env.NEXT_PUBLIC_DEMO_PRIVATE_KEY ||
  "0xe5be9a5092b81bca64be81d212e7f2f9eba183bb7a90954f7b76361f6edb5c0a";

export async function varaPaymentHeader(paymentDetails: PaymentRequiredResponse) {
  // Parse the 402 response which should contain accepts array per x402 spec
  const paymentReqs = paymentDetails.accepts?.[0] || paymentDetails;

  // Initialize Aptos client
  const api = await useApi(paymentReqs.network);

  // Create account from hardcoded private key
  const keyring = new Keyring({ type: "sr25519", ss58Format: 137 });
  const account = keyring.addFromSeed(hexToU8a(DEMO_PRIVATE_KEY));

  // Build transaction
  const tx = api.tx.balances.transferKeepAlive(paymentReqs.payTo, paymentReqs.maxAmountRequired);

  // Get PayloadJSON
  const unsignedTransaction = await createUnsignedTransaction(api, account.address, tx);

  // Get signature
  const { signature } = await signWithKeypair(account, unsignedTransaction, api);

  // Serialize transaction and signature separately
  const signedTxPayload = {
    signature: signature,
    transaction: unsignedTransaction,
  };

  console.log("Transaction and signature:", signedTxPayload);

  // Create x402 PaymentPayload per official spec
  const paymentPayload : PaymentPayload = {
    x402Version: 1,
    scheme: "exact",
    network: paymentReqs.network || "vara-testnet",
    payload: signedTxPayload,
  };

  // Base64 encode the PaymentPayload JSON for X-PAYMENT header
  const paymentHeader = Buffer.from(JSON.stringify(paymentPayload)).toString(
    "base64",
  );

  console.log("x402 Payment Payload:", {
    x402Version: paymentPayload.x402Version,
    scheme: paymentPayload.scheme,
    network: paymentPayload.network,
    sender: unsignedTransaction.address,
    // hasSignature: !!signedTxPayload.signature,
    // hasTransaction: !!signedTxPayload.transaction,
    // signatureLength: signedTxPayload.signature?.length,
    // txLength: signedTxPayload.transaction?.length,
    headerLength: paymentHeader.length,
  });

  return paymentHeader;
}
