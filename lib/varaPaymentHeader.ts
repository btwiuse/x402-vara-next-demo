"use client";

import { PaymentRequiredResponse, PaymentRequirements, PaymentPayload } from '@/lib/x402-protocol-types';
import { useApi, createUnsignedTransaction } from 'x402-vara/utils';
import { Keyring } from "@polkadot/keyring";
import { hexToU8a, u8aToHex } from '@polkadot/util'
import { decodeAddress, cryptoWaitReady } from '@polkadot/util-crypto'
import { VftProgram } from 'x402-vara/lib'
import { signWithKeypair } from 'x402-vara/client';
import type { WalletKeypair } from 'x402-vara';

// Demo private key (generated by scripts/generate-account.ts)
const DEMO_PRIVATE_KEY = process.env.NEXT_PUBLIC_DEMO_PRIVATE_KEY ||
  "0xe5be9a5092b81bca64be81d212e7f2f9eba183bb7a90954f7b76361f6edb5c0a";

export async function DemoAccount(): Promise<WalletKeypair> {
  await cryptoWaitReady();
  // create account from hardcoded private key
  const keyring = new Keyring({ type: "sr25519", ss58Format: 137 });
  const account = keyring.addFromSeed(hexToU8a(DEMO_PRIVATE_KEY));
  return account
}

export function buildTransferTx(api: any, paymentReqs: PaymentRequirements) {
  const { asset, payTo, maxAmountRequired } = paymentReqs;
  if (!asset) {
    return api.tx.balances.transferKeepAlive(payTo, maxAmountRequired);
  }
  const vft = new VftProgram(api, asset);
  const txBuilder = vft.vft.transfer(u8aToHex(decodeAddress(payTo)), maxAmountRequired);
  txBuilder.withGas('max');
  return txBuilder.extrinsic;
}

export async function varaPaymentHeader(paymentDetails: PaymentRequiredResponse, account: WalletKeypair, selectedIndex: number = 0) {
  // Parse the 402 response which should contain accepts array per x402 spec
  const paymentReqs = paymentDetails.accepts?.[selectedIndex] || paymentDetails;

  // Initialize Aptos client
  const api = await useApi(paymentReqs.network);

  // Build transaction
  const tx = buildTransferTx(api, paymentReqs);

  // Get PayloadJSON
  const unsignedTransaction = await createUnsignedTransaction(api, account.address, tx);

  const { signWithAuto } = await import('x402-vara/browser');

  // Get signature
  const { signature } = await signWithAuto(account, unsignedTransaction, api);

  // Serialize transaction and signature separately
  const signedTxPayload = {
    signature: signature,
    transaction: unsignedTransaction,
  };

  console.log("Transaction and signature:", signedTxPayload);

  // Create x402 PaymentPayload per official spec
  const paymentPayload : PaymentPayload = {
    x402Version: 1,
    scheme: "exact",
    asset: paymentReqs.asset,
    network: paymentReqs.network || "vara-testnet",
    payload: signedTxPayload,
  };

  // Base64 encode the PaymentPayload JSON for X-PAYMENT header
  const paymentHeader = Buffer.from(JSON.stringify(paymentPayload)).toString(
    "base64",
  );

  console.log("x402 Payment Payload:", {
    x402Version: paymentPayload.x402Version,
    scheme: paymentPayload.scheme,
    asset: paymentReqs.asset,
    network: paymentPayload.network,
    sender: unsignedTransaction.address,
    // hasSignature: !!signedTxPayload.signature,
    // hasTransaction: !!signedTxPayload.transaction,
    // signatureLength: signedTxPayload.signature?.length,
    // txLength: signedTxPayload.transaction?.length,
    headerLength: paymentHeader.length,
  });

  return paymentHeader;
}
